#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Package for doing a basic data reduction on the fakes images generated by
insert_fakes.py, including sky-subtraction and image coaddition.
"""


import numpy as np
from scipy import ndimage
from astropy.io import fits
from astropy.wcs import WCS
from astropy.modeling.models import Legendre2D
from astropy.modeling.fitting import LevMarLSQFitter
from skimage.restoration import inpaint
import cv2
import glob
import os

import utility as ut
from fakes import insert_fakes as insfk


def makeHduList(image, header=None):
    '''
    Creates an HDUList object from an image array and a FITS header object
        Parameters
        ----------
        image : `numpy.ndarray`
            Image data array
        header : `astropy.io.fits.Header`
            Header object to be included with the data array.
            Defaults to None

        Returns
        -------
        hduList : `astropy.io.fits.HDUList`
            Image with header HDUList object (writable)
    '''
    hdu = fits.PrimaryHDU(image, header=header)
    hduList = fits.HDUList([hdu])

    return hduList


def getFnames(dirNm, prefix='fakes', prefixNoNoise='onlymodels'):
    '''
    Makes a list of file names for images to be processed
        Parameters
        ----------
        dirNm : `string`
            Directory in which to find the images (excluding trailing /)
        prefix : `string`
            Common image name prefix prior to wildcard

        Returns
        -------
        imList : `list`
            List of filenames and associated directory
        imListNoNoise : `list`
            List of associated noiseless image filenames
    '''
    imList = glob.glob(dirNm + '/' + prefix + '*.fits')
    inds = [int(i[i.find(prefix)+len(prefix):-5]) for i in imList]
    idx = np.argsort(inds)
    imList = list(np.array(imList)[idx])
    imListNoNoise = [dirNm + '/' + prefixNoNoise + str(i)
                     + '.fits' for i in np.array(inds)[idx]]

    return imList, imListNoNoise


def makeBlankImage(raCen, decCen, size, pxScale=0.168):
    '''
    Creates a blank image HDU with a WCS
        Parameters
        ----------
        raCen : `float`
            Central pixel reference right ascension, in decimal degrees
        decCen : `float`
            Central pixel reference declination, in decimal degrees
        size : `int`
            Width of blank image in pixels
        pxScale : `float`
            Pixel scale, in arcsec/px, for the blank image

        Returns
        -------
        blankHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image HDU with given parameters, all zero data values
    '''
    assert (raCen >= 0) & (raCen <= 360), \
        'Invalid RA: use decimal degrees.'
    assert (decCen >= -90) & (decCen <= 90), \
        'Invalid Dec: use decimal degrees.'
    assert size > 0, \
        'Size must be finite and non-zero'
    assert pxScale > 0, \
        'pxScale must be finite and non-zero'
    dimX = size
    dimY = size
    blnkIm = insfk.ImageBuilder(dimX, dimY, raCen, decCen, pxScale, {})
    hdu = fits.PrimaryHDU(blnkIm.image.array, header=blnkIm.w.to_header())
    blankHdu = fits.HDUList([hdu])

    return blankHdu


def binImage(maskedHdu, block=9):
    '''
    Median bins image into block*block pixels.  Assumes masked pixels are NaN.
        Parameters
        ----------
        maskedHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image to be binned
        block : `int`
            Binning factor in pixels

        Returns
        -------
        binnedHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Binned image, with scaled WCS if applicable
    NOTE: this doesn't allow for higher-order terms like PC3_J, PC4_J, etc.
    '''
    assert block > 0, 'Binning factor must be positive and non-zero'
    assert maskedHdu[0].header['NAXIS1'] == maskedHdu[0].data.shape[1], \
        'Header mismatch or non-existent.  Image needs a header.'
    assert ('PC1_1' in maskedHdu[0].header) \
        | ('CD1_1' in maskedHdu[0].header), \
        'WCS info in header must be in either PCI_J or CDI_J format.'

    # First converting header to CDI_J format if not already there
    keys = ['PC1_1', 'PC1_2', 'PC2_1', 'PC2_2']
    for key in keys:
        if key in maskedHdu[0].header:
            cdKey = 'CD'+key[2:]
            if key[2] == '1':
                maskedHdu[0].header[cdKey] = maskedHdu[0].header[key] \
                    * maskedHdu[0].header['CDELT1']
            else:
                maskedHdu[0].header[cdKey] = maskedHdu[0].header[key] \
                    * maskedHdu[0].header['CDELT2']
            maskedHdu[0].header.remove(key)

    # Shaving off excess pixels given bin size
    x_edge = np.shape(maskedHdu[0].data)[0] % block
    y_edge = np.shape(maskedHdu[0].data)[1] % block
    im_shape = np.shape(maskedHdu[0].data[x_edge:, y_edge:])

    # Reshape image array into arrays of block x block
    bin_im = np.reshape(maskedHdu[0].data[x_edge:, y_edge:],
                        (im_shape[0]//block,
                         block,
                         im_shape[1]//block,
                         block)
                        )

    # Have to keep bins with very few masked pixels from skewing the results
    binned = np.zeros((im_shape[0]//block, im_shape[1]//block))
    for i in range(bin_im.shape[0]):
        for j in range(bin_im.shape[2]):
            box = bin_im[i, :, j, :]
            msk = np.isfinite(box)
            if len(msk[msk]) <= (2*len(msk.flatten()))//3:
                binned[i, j] = np.nan
            else:
                binned[i, j] = np.nanmedian(box)

    # Transform WCS to the binned coordinate system
    bn_head = maskedHdu[0].header.copy()
    bn_head['CRPIX1'] = bn_head['CRPIX1']/block
    bn_head['CRPIX2'] = bn_head['CRPIX2']/block
    if 'CD1_1' in bn_head:
        bn_head['CD1_1'] = bn_head['CD1_1']*block
    if 'CD2_2' in bn_head:
        bn_head['CD2_2'] = bn_head['CD2_2']*block
    if 'CD1_2' in bn_head:
        bn_head['CD1_2'] = bn_head['CD1_2']*block
    if 'CD2_1' in bn_head:
        bn_head['CD2_1'] = bn_head['CD2_1']*block

    hdu = fits.PrimaryHDU(binned, header=bn_head)
    binnedHdu = fits.HDUList([hdu])

    return binnedHdu


def maskToLimit(imageNoSky, sbLim, magZp, pxScale=0.168):
    '''
    Creates an object mask out to a specified surface brightness limit
        Parameters
        ----------
        imageNoSky : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image with only objects; no noise or sky, BG 0 counts
        sbLim : `float`
            Surface brightness limit out to which to create masks
        magZp : `float`
            Zeropoint for converting from magnitudes to counts
        pxScale : `float`
            Pixel scale in arcsec per pixel

        Returns
        -------
        maskImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            Boolean mask HDU, where True is masked and False is not
    '''
    # Converting surface brightness to counts
    countLim = 10**(-0.4*(sbLim - magZp - 2.5*np.log10(pxScale**2)))
    mask = imageNoSky[0].data >= countLim
    mask = np.array(mask, dtype=int)
    maskImage = makeHduList(mask)

    return maskImage


def legendreSkySub(polyOrder, maskedImage, bnFac, maskVal=np.nan, full=False):
    '''
    Models and subtracts the sky using Legendre polynomials
        Parameters
        ----------
        polyOrder : `int`
            Order of desired Legendre polynomial fit to the image background
        maskedImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            HDUList of input image, with mask applied via maskVal
        bnFac : `int`
            Binning factor to be applied to maskedImage before fitting sky
        maskVal : `float`
            Pixel value corresponding to mask in maskedImage
            (Defaults to np.nan)
        full : `bool`
            If True, returns the parameters of the fit as well

        Returns
        -------
        skyModel : `numpy.ndarray`
            Best-fit sky model image, at native resolution
        m : `astropy.modeling.FittableModel`
            Model fit with full parameters (accessed via m.c0_0, m.c1_0, etc.)
    '''
    assert type(maskedImage) == fits.hdu.hdulist.HDUList, \
        'Input masked image must be an HDUList, with a header'
    assert (polyOrder >= 0), \
        'Polynomial order must be 0 or positive'
    assert (bnFac > 0), \
        'Bin factor must be > 0'
    zeros = maskedImage[0].data == 0
    assert len(zeros[~zeros]) != 0, \
        'Image is all 0s; cannot hope to fit a blank image.'

    m_init = Legendre2D(polyOrder, polyOrder)
    fit = LevMarLSQFitter()

    try:
        binnedImage = binImage(maskedImage, bnFac)
    except AssertionError:
        print('maskedImage must have a valid WCS header to bin!')
        return
    bnx = np.arange(bnFac//2+1, binnedImage[0].data.shape[1]*bnFac, bnFac)
    bny = np.arange(bnFac//2+1, binnedImage[0].data.shape[0]*bnFac, bnFac)
    bnX, bnY = np.meshgrid(bnx, bny)
    _sky = np.nanmedian(binnedImage[0].data[binnedImage[0].data != maskVal])
    _dsky = np.nanstd(binnedImage[0].data[binnedImage[0].data != maskVal])

    # Accepting only pixels within 3 standard deviations of background
    good = (binnedImage[0].data > _sky-3*_dsky) & \
           (binnedImage[0].data < _sky+3*_dsky)

    # Fitter can't handle np.nan
    binnedImage[0].data[np.isnan(binnedImage[0].data)] = -999

    # Rejecting outliers; 3 rounds 3 sigma rejection
    for i in range(3):
        m = fit(m_init, bnX, bnY, binnedImage[0].data, weights=good)
        scatter = np.nanstd(m(bnX[good], bnY[good])
                            - binnedImage[0].data[good])
        diff = binnedImage[0].data - m(bnX, bnY)
        good = good & (np.abs(diff) < (3 * scatter))
        m_init = m

    # Doing final fit and sky subtraction
    x = np.arange(1, maskedImage[0].data.shape[1]+1)
    y = np.arange(1, maskedImage[0].data.shape[0]+1)
    X, Y = np.meshgrid(x, y)
    m = fit(m_init, bnX, bnY, binnedImage[0].data, weights=good)
    skyModel = m(X, Y)

    if full:
        return skyModel, m

    else:
        return skyModel


def coaddImages(raCen, decCen, size, imDict, offsets, pxScale=0.168,
                prefix='', outputDir='.', writeIms=False):
    '''
    Registers and median coadds all images using a blank reference image
        Parameters
        ----------
        raCen : `float`
            Central pixel reference right ascension, in decimal degrees
        decCen : `float`
            Central pixel reference declination, in decimal degrees
        size : `int`
            Width of blank image in pixels
        imDict : `list`
            Dictionary containing image data for all images to be combined
        offsets : `list`
            List of (dx, dy) offsets from field center in px.  Returned from
            fakes.insert_fakes.ImageBuilder.ditheredCoordinates()
        pxScale : `float`
            Pixel scale, in arcsec/px, for the blank image on which to register
            the other images
        prefix : `string`
            Image prefix appended to registered images if writeIms == True
        outputDir : `string`
            Path to directory in which to write registered image files if
            writeIms == True
        writeIms : `bool`
            If True, will write registered images to the disk in addition to
            the coadded image itself

        Returns
        -------
        coaddHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Images coadded onto the reference blankImage, with header
    '''
    assert type(imDict) == dict, \
        'Image list must be a dictionary containing image HDU objects'
    keys = list(imDict.keys())
    assert type(imDict[keys[0]]) == fits.hdu.hdulist.HDUList, \
        'Images in imDict must be of type HDUList'
    assert type(prefix) == str
    assert type(outputDir) == str
    assert type(offsets) == list, \
        'Offsets must be in list format: [(dx1, dy1), (dx2, dy2), ...]'
    assert type(offsets[0]) == tuple, \
        'Offsets must be in list format: [(dx1, dy1), (dx2, dy2), ...]'
    for i in offsets:
        assert np.round(i[0], 0) == i[0], \
            'Offsets must be integers!'
        assert np.round(i[1], 0) == i[1], \
            'Offsets must be integers!'

    blankImage = makeBlankImage(raCen, decCen, size, pxScale)
    # Checking that raCen, decCen corresponds to the same field center used
    # to produce the dithered offsets, so partial pixels are not involved.
    dxTst = imDict[keys[0]][0].header['CRPIX1'] \
        - blankImage[0].header['CRPIX1']
    assert np.round(dxTst, 0) == dxTst, \
        'Non-integer offset from field center found.  Did you use the same' \
        + ' RA, Dec as the chosen field center?'
    allIms = []
    for i, im in enumerate(imDict.keys()):
        try:
            print('Registering image ' + im + ' of ', len(imDict))
        except TypeError:
            print('Registering image %i' % (im) + ' of ', len(imDict))
        image = imDict[im]

        # Inject image into the right place on the blank image
        proj_im = blankImage[0].data * 0.0 + np.nan
        left_edge = (size//2) - (image[0].data.shape[1]//2 - offsets[i][0])
        bottom_edge = (size//2) - (image[0].data.shape[0]//2 - offsets[i][1])

        proj_im[bottom_edge: bottom_edge + image[0].data.shape[0],
                left_edge: left_edge + image[0].data.shape[1]] \
            = image[0].data

        allIms.append(proj_im)
        if writeIms:
            ut.write_im_head(proj_im, blankImage[0].header,
                             outputDir+'/'+prefix+'fakes'+str(i)+'.fits')

    coadd = np.nanmedian(allIms, axis=0)
    hdu = fits.PrimaryHDU(coadd, header=blankImage[0].header)
    coaddHdu = fits.HDUList([hdu])

    return coaddHdu


def coaddSubtraction(image, offset, coadd, scaleFac=1.0):
    '''
    Aligns, flux-scales, and subtracts the coadd from an individual image
        Parameters
        ----------
        image : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image from which the coadd is to be subtracted
        offset : `tuple`
            Image shift used to reverse the coadd, (dx, dy)
        coadd : `astropy.io.fits.hdu.image.PrimaryHDU`
            The coadd to subtract from the image
        scaleFac : `float`
            Amount by which to multiple the coadd before subtraction, to match
            to the individual exposure's zeropoint

        Returns
        -------
        diffImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            The coadd-subtracted image
    '''
    assert type(image) == fits.hdu.hdulist.HDUList, \
        'Input image must be of type HDUList'
    assert type(coadd) == fits.hdu.hdulist.HDUList, \
        'Coadd image must be of type HDUList'
    assert type(offset) == tuple, \
        'Offset must be in tuple format: (dx, dy)'
    assert np.round(offset[0], 0) == offset[0], \
        'Offsets must be integers!'
    assert np.round(offset[1], 0) == offset[1], \
        'Offsets must be integers!'

    # Setting up some quantities
    size = coadd[0].data.shape[0]  # Always a square
    image_x = image[0].data.shape[1]
    image_y = image[0].data.shape[0]

    # Uses 0 order shift, as these all should be integers
    # Moves the image section to the coadd center
    reproj_coadd = ndimage.shift(coadd[0].data,
                                 [-offset[1], -offset[0]],
                                 order=0, cval=np.nan)
    # Then take only the center slice with the image dimensions
    if image_y % 2 == 0:
        reproj_coadd = reproj_coadd[size//2 - image_y//2: size//2 + image_y//2,
                                    size//2 - image_x//2: size//2 + image_x//2]
    # int(0.5) == 1 in Python, so odd numbers go up by 1
    else:
        reproj_coadd = reproj_coadd[size//2 - image_y//2:
                                    size//2 + image_y//2 + 1,
                                    size//2 - image_x//2:
                                        size//2 + image_x//2]

    # Scaling the flux to the individual exposure via scaleFactor
    # Derive this separately
    reproj_coadd *= scaleFac
    diffData = image[0].data - reproj_coadd

    diffHdu = fits.PrimaryHDU(diffData, header=image[0].header)
    diffImage = fits.HDUList([diffHdu])

    return diffImage


def makeSkyMap(skyImage, binnedHdu, sigma=1.0, block=9):
    '''
    Fills flux in binned image across masks using inpainting, applies a lowpass
    filter, then enlarges image to original size
        Parameters
        ----------
        skyImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            The standard resolution coadd-subtracted image HDUList
        binnedHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Masked, binned image HDUList to be inpainted
        sigma : `float`
            Standard deviation of Gaussian kernel used for lowpass filtering
        block : `int`
            Binning factor in pixels

        Returns
        -------
        skyMap : `astropy.io.fits.hdu.image.PrimaryHDU`
            Smooth, mostly noiseless version of skyImage
    '''
    assert type(skyImage) == fits.hdu.hdulist.HDUList, \
        'Input image must be of type HDUList'
    assert type(binnedHdu) == fits.hdu.hdulist.HDUList, \
        'Input binned image must be of type HDUList'
    assert sigma > 0, 'Gaussian kernel standard deviation must be positive'
    assert block > 0, 'Bin factor must be positive'
    assert type(block) == int, 'Bin factor must be an integer value'

    y_edge = np.shape(skyImage[0].data)[0] % block
    x_edge = np.shape(skyImage[0].data)[1] % block
    if (x_edge != 0) | (y_edge != 0):
        print('Warning!  Image dimensions not evenly divisible by bin factor.')
        print('Strange things might occur at the image edges.')

    # Interpolate flux across masks using Inpainting technique
    bn_msk = np.isnan(binnedHdu[0].data)
    binned = inpaint.inpaint_biharmonic(binnedHdu[0].data, bn_msk)

    # Smooth the image
    binned = ndimage.gaussian_filter(binned, sigma)

    # Enlarged version of the binned image
    enlarged_image = cv2.resize(binned,
                                (binned.shape[1]*block, binned.shape[0]*block),
                                interpolation=cv2.INTER_LANCZOS4)

    # Extrapolates missing pixel values from the binned image edges
    skyMap = np.zeros(skyImage[0].data.shape) + np.nan
    skyMap[y_edge:, x_edge:] = enlarged_image
    skyMap[:y_edge, :] = skyMap[y_edge:2*y_edge, :]
    skyMap[:, :x_edge] = skyMap[:, x_edge:2*x_edge]

    return skyMap
