#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Package for doing a basic data reduction on the fakes images generated by
insert_fakes.py, including sky-subtraction and image coaddition.
"""


import numpy as np
from scipy import ndimage
from astropy.io import fits
from astropy.wcs import WCS
from astropy.modeling.models import Legendre2D
from astropy.modeling.fitting import LevMarLSQFitter
from skimage.restoration import inpaint
import cv2
import glob
import os

import utility as ut
from fakes import insert_fakes as insfk


def makeHduList(image, header=None):
    '''
    Creates an HDUList object from an image array and a FITS header object
        Parameters
        ----------
        image : `numpy.array`
            Image data array
        header : `astropy.io.fits.Header`
            Header object to be included with the data array.
            Defaults to None

        Returns
        -------
        hduList : `astropy.io.fits.HDUList`
            Image with header HDUList object (writable)
    '''
    hdu = fits.PrimaryHDU(image, header=header)
    hduList = fits.HDUList([hdu])

    return hduList


def getFnames(dirNm, prefix='fakes', prefixNoNoise='onlymodels'):
    '''
    Makes a list of file names for images to be processed
        Parameters
        ----------
        dirNm : `string`
            Directory in which to find the images (excluding trailing /)
        prefix : `string`
            Common image name prefix prior to wildcard

        Returns
        -------
        imList : `list`
            List of filenames and associated directory
        imListNoNoise : `list`
            List of associated noiseless image filenames
    '''
    imList = glob.glob(dirNm + '/' + prefix + '*.fits')
    inds = [int(i[i.find(prefix)+len(prefix):-5]) for i in imList]
    idx = np.argsort(inds)
    imList = list(np.array(imList)[idx])
    imListNoNoise = [dirNm + '/' + prefixNoNoise + str(i)
                     + '.fits' for i in np.array(inds)[idx]]

    return imList, imListNoNoise


def makeBlankImage(raCen, decCen, size, pxScale):
    '''
    Creates a blank image HDU with a WCS
        Parameters
        ----------
        raCen : `float`
            Central pixel reference right ascension, in decimal degrees
        decCen : `float`
            Central pixel reference declination, in decimal degrees
        size : `int`
            Width of blank image in pixels

        Returns
        -------
        blankImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image HDU with given parameters, all zero data values
    '''
    dimX = size
    dimY = size
    blnkIm = insfk.ImageBuilder(dimX, dimY, raCen, decCen, pxScale)
    hdu = fits.PrimaryHDU(blnkIm.image.array, header=blnkIm.w.to_header())
    hdulist = fits.HDUList([hdu])

    return hdulist


def binImage(maskedHdu, block=9):
    '''
    Median bins image into block*block pixels.  Assumes masked pixels are NaN.
        Parameters
        ----------
        maskedHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image to be binned
        block : `int`
            Binning factor in pixels

        Returns
        -------
        binnedHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Binned image, with scaled WCS if applicable
    '''
    # Shaving off excess pixels given bin size
    x_edge = np.shape(maskedHdu[0].data)[0] % block
    y_edge = np.shape(maskedHdu[0].data)[1] % block
    im_shape = np.shape(maskedHdu[0].data[x_edge:, y_edge:])

    # Reshape image array into arrays of block x block
    bin_im = np.reshape(maskedHdu[0].data[x_edge:, y_edge:],
                        (im_shape[0]//block,
                         block,
                         im_shape[1]//block,
                         block)
                        )

    # Have to keep bins with very few masked pixels from skewing the results
    binned = np.zeros((im_shape[0]//block, im_shape[1]//block))
    for i in range(bin_im.shape[0]):
        for j in range(bin_im.shape[2]):
            box = bin_im[i, :, j, :]
            msk = np.isfinite(box)
            if len(msk[msk]) <= (2*len(msk.flatten()))//3:
                binned[i, j] = np.nan
            else:
                binned[i, j] = np.nanmedian(box)

    # Transform WCS to the binned coordinate system
    bn_head = maskedHdu[0].header.copy()
    bn_head['CRPIX1'] = bn_head['CRPIX1']/block
    bn_head['CRPIX2'] = bn_head['CRPIX2']/block
    if 'CD1_1' in bn_head:
        bn_head['CD1_1'] = bn_head['CD1_1']*block
    if 'CD2_2' in bn_head:
        bn_head['CD2_2'] = bn_head['CD2_2']*block
    if 'CD1_2' in bn_head:
        bn_head['CD1_2'] = bn_head['CD1_2']*block
    if 'CD2_2' in bn_head:
        bn_head['CD2_1'] = bn_head['CD2_1']*block

    hdu = fits.PrimaryHDU(binned, header=bn_head)
    binnedHdu = fits.HDUList([hdu])

    return binnedHdu


def maskToLimit(imageNoSky, sbLim, magZp, pxScale=0.168):
    '''
    Creates an object mask out to a specified surface brightness limit
        Parameters
        ----------
        imageNoSky : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image with only objects; no noise or sky, BG 0 counts
        sbLim : `float`
            Surface brightness limit out to which to create masks
        magZp : `float`
            Zeropoint for converting from magnitudes to counts
        pxScale : `float`
            Pixel scale in arcsec per pixel

        Returns
        -------
        maskImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            Boolean mask HDU, where True is masked and False is not
    '''
    # Converting surface brightness to counts
    countLim = 10**(-0.4*(sbLim - magZp - 2.5*np.log10(pxScale**2)))
    mask = imageNoSky[0].data >= countLim
    mask = np.array(mask, dtype=int)
    maskImage = makeHduList(mask)

    return maskImage


def createNCMask(imagePath, prefix='fakes', commands=''):
    '''
    Creates a mask file by running GNUAstro package NoiseChisel on the
    image provided
        Parameters
        ----------
        imagePath : `string`
            Full path to image you want masked
        prefix : `string`
            Common image name prefix prior to wildcard
        commands : `string`
            Additional desired commands to be used by astnoisechisel

        Returns
        -------
        ncDetections : `numpy.array`
            Detection map from Noisechisel, 1==masked, 0==not masked

    '''
    imName = imagePath[imagePath.find(prefix):]
    os.system('astnoisechisel '+imagePath+' -h0 --rawoutput '+commands)

    ncCube = fits.open(imName[:-5]+'_detected.fits')
    ncDetections = ncCube[1].data

    return ncDetections


def legendreSkySub(polyOrder, maskedImage, bnFac, maskVal=np.nan, full=False):
    '''
    Models and subtracts the sky using Legendre polynomials
        Parameters
        ----------
        polyOrder : `int`
            Order of desired Legendre polynomial fit to the image background
        maskedImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            Binned image with masked pixels
        bnFac : `int`
            Binning factor applied to maskedImage (more binning speeds this up)
        maskVal : `float`
            Pixel value corresponding to mask in maskImage (defaults to np.nan)
        full : `bool`
            If True, returns the parameters of the fit as well

        Returns
        -------
        skyModel : `numpy.array`
            Best-fit sky model image
        m : `astropy.modeling.FittableModel`
            Model fit with full parameters
    '''
    m_init = Legendre2D(polyOrder, polyOrder)
    fit = LevMarLSQFitter()

    bnx = np.arange(bnFac//2+1, maskedImage[0].data.shape[1]*bnFac, bnFac)
    bny = np.arange(bnFac//2+1, maskedImage[0].data.shape[0]*bnFac, bnFac)
    bnX, bnY = np.meshgrid(bnx, bny)
    _sky = np.nanmedian(maskedImage[0].data[maskedImage[0].data != maskVal])
    _dsky = np.nanstd(maskedImage[0].data[maskedImage[0].data != maskVal])

    # Accepting only pixels within 3 standard deviations of background
    good = (maskedImage[0].data > _sky-3*_dsky) & \
           (maskedImage[0].data < _sky+3*_dsky)

    # Fitter can't handle np.nan
    maskedImage[0].data[np.isnan(maskedImage[0].data)] = -999

    # Rejecting outliers; 3 rounds 3 sigma rejection
    for i in range(3):
        m = fit(m_init, bnX, bnY, maskedImage[0].data, weights=good)
        scatter = np.nanstd(m(bnX[good], bnY[good])
                            - maskedImage[0].data[good])
        diff = maskedImage[0].data - m(bnX, bnY)
        good = good & (np.abs(diff) < (3 * scatter))
        m_init = m

    # Doing final fit and sky subtraction
    x = np.arange(1, maskedImage[0].data.shape[1]*bnFac+1)
    y = np.arange(1, maskedImage[0].data.shape[0]*bnFac+1)
    X, Y = np.meshgrid(x, y)
    m = fit(m_init, bnX, bnY, maskedImage[0].data, weights=good)
    skyModel = m(X, Y)

    if full:
        return skyModel, m

    else:
        return skyModel


def coaddImages(imList, blankImage, bWidth, prefix='s_fakes', writeIms=False):
    '''
    Registers and median coadds all images using a blank reference image
        Parameters
        ----------
        imList : `list`
            List of image filenames
        blankImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            All zero image w/WCS, image on which to register all others
        prefix : `string`
            Common image name prefix prior to wildcard
        writeIms : `bool`
            If True, will write registered images to the disk

        Returns
        -------
        coaddHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Images coadded onto the reference blankImage, with header

        shifts : `list`
            List of tuples giving shifts in y and then x used to align images
    '''
    allIms = []
    shifts = []
    for im in imList:
        print('Registering image '+im)
        image = fits.open(im)
        fnm = im[im.find(prefix):]
        dirnm = im[:im.find(prefix)]

        star_x = image[0].header['STAR_X']
        star_y = image[0].header['STAR_Y']
        w1 = WCS(image[0].header)
        w2 = WCS(blankImage[0].header)
        star_ra, star_dec = w1.all_pix2world(star_x, star_y, 1)
        ref_x, ref_y = w2.all_world2pix(star_ra, star_dec, 1)
        dx = ref_x - star_x
        dy = ref_y - star_y
        shifts.append((dy, dx))

        proj_im = np.ndarray.copy(blankImage[0].data)
        proj_im[: image[0].data.shape[0],
                : image[0].data.shape[1]] = image[0].data
        proj_im = ndimage.shift(proj_im, [dy, dx], order=5)
        allIms.append(proj_im)
        if writeIms:
            ut.write_im_head(proj_im, blankImage[0].header, dirnm+'W'+fnm)

    coadd = np.nanmedian(allIms, axis=0)
    hdu = fits.PrimaryHDU(coadd, header=blankImage[0].header)
    coaddHdu = fits.HDUList([hdu])

    return coaddHdu, shifts


def coaddSubtraction(image, shift, coadd):
    '''
    Aligns and subtracts the coadd from an individual image
        Parameters
        ----------
        image : `astropy.io.fits.hdu.image.PrimaryHDU`
            Image from which the coadd is to be subtracted
        shifts : `tuple`
            Image shift used to reverse the coadd, (dx, dy)
        coadd : `astropy.io.fits.hdu.image.PrimaryHDU`
            The coadd to subtract from the image

        Returns
        -------
        diffImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            The coadd-subtracted image
    '''
    reproj_coadd = ndimage.shift(coadd[0].data,
                                 [-shift[0], -shift[1]],
                                 order=5)
    reproj_coadd = reproj_coadd[: image[0].data.shape[0],
                                : image[0].data.shape[1]]

    # Scale factor derivation goes here, using a separate function
    scaleFac = 1.0
    reproj_coadd *= scaleFac
    diffData = image[0].data - reproj_coadd

    diffHdu = fits.PrimaryHDU(diffData, header=image[0].header)
    diffImage = fits.HDUList([diffHdu])

    return diffImage


def makeSkyMap(imageHdu, binnedHdu, sigma=1.0, block=9):
    '''
    Fills flux in binned image across masks using inpainting, applies a lowpass
    filter, then enlarges image to original size
        Parameters
        ----------
        diffImage : `astropy.io.fits.hdu.image.PrimaryHDU`
            The coadd-subtracted image
        binnedHdu : `astropy.io.fits.hdu.image.PrimaryHDU`
            Binned image to be inpainted
        sigma : `float`
            Standard deviation of Gaussian kernel used for lowpass filtering
        block : `int`
            Binning factor in pixels

        Returns
        -------
        skyMap : `astropy.io.fits.hdu.image.PrimaryHDU`
            Smooth maps of the sky
    '''
    x_edge = np.shape(imageHdu[0].data)[0] % block
    y_edge = np.shape(imageHdu[0].data)[1] % block

    # Interpolate flux across masks using Inpainting technique
    bn_msk = np.isnan(binnedHdu[0].data)
    binned = inpaint.inpaint_biharmonic(binnedHdu[0].data, bn_msk)

    # Smooth the image
    binned = ndimage.gaussian_filter(binned, sigma)

    # Enlarged version of the binned image
    enlarged_image = cv2.resize(binned,
                                (binned.shape[1]*block, binned.shape[0]*block),
                                interpolation=cv2.INTER_LANCZOS4)

    # Extrapolates missing pixel values from the binned image edges
    skyMap = np.zeros(imageHdu[0].data.shape) + np.nan
    skyMap[x_edge:, y_edge:] = enlarged_image
    skyMap[:x_edge, :] = skyMap[x_edge:2*x_edge, :]
    skyMap[:, :y_edge] = skyMap[:, y_edge:2*y_edge]

    return skyMap
